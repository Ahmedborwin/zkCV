import {
  __async
} from "./chunk-ZNQPCYQG.js";
import "./chunk-DHSMPHVW.js";
import {
  ChainNotConfiguredError,
  Connector,
  ConnectorNotFoundError,
  createWalletClient,
  custom
} from "./chunk-DHWG5WZJ.js";
import "./chunk-7VI2C3EH.js";
import "./chunk-L3LPOETZ.js";
import {
  SwitchChainError,
  UserRejectedRequestError,
  getAddress
} from "./chunk-6LWN5ATN.js";
import "./chunk-Y7B5QXLX.js";
import "./chunk-LMJRRKLH.js";
import "./chunk-M5UDYYE2.js";
import "./chunk-AVK47F2P.js";
import "./chunk-IKJM6GHQ.js";

// node_modules/@particle-network/rainbowkit-ext/dist/index.js
function titleCase(str) {
  if (!str) {
    return "";
  }
  return str.replace(/\w\S*/g, function(txt) {
    return txt.charAt(0).toUpperCase() + txt.slice(1).toLowerCase();
  });
}
var ParticleConnector = class extends Connector {
  constructor() {
    super(...arguments);
    this.id = "particle";
    this.name = "Particle";
    this.ready = true;
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress(accounts[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id = Number(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", { chain: { id, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  connect() {
    return __async(this, arguments, function* ({ chainId } = {}) {
      if (!this.options.auth) {
        throw new Error("Please init Particle first");
      }
      try {
        const provider = yield this.getProvider();
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
        this.emit("message", { type: "connecting" });
        if (!this.options.auth.isLogin()) {
          yield this.options.auth.login({
            preferredAuthType: this.options.authType
          });
        }
        let id = yield this.getChainId();
        let unsupported = this.isChainUnsupported(id);
        if (chainId && id !== chainId) {
          const chain = yield this.switchChain(chainId);
          id = chain.id;
          unsupported = this.isChainUnsupported(id);
        }
        const account = yield this.getAccount();
        return {
          account,
          chain: { id, unsupported }
        };
      } catch (error) {
        if (error.code === 4001) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    });
  }
  disconnect() {
    return __async(this, null, function* () {
      const provider = yield this.getProvider();
      yield provider.disconnect();
      provider.removeListener("accountsChanged", this.onAccountsChanged);
      provider.removeListener("chainChanged", this.onChainChanged);
      provider.removeListener("disconnect", this.onDisconnect);
    });
  }
  getAccount() {
    return __async(this, null, function* () {
      const provider = yield this.getProvider();
      const accounts = yield provider.request({ method: "eth_accounts" });
      return getAddress(accounts[0]);
    });
  }
  getChainId() {
    return __async(this, null, function* () {
      const provider = yield this.getProvider();
      const chainId = yield provider.request({ method: "eth_chainId" });
      return Number(chainId);
    });
  }
  getProvider() {
    return __async(this, null, function* () {
      if (!this.options.auth) {
        throw new Error("Please init Particle first");
      }
      if (!this.provider) {
        const { ParticleProvider } = yield import("./es-HPNP6I3Y.js");
        this.provider = new ParticleProvider(this.options.auth);
      }
      return this.provider;
    });
  }
  getWalletClient() {
    return __async(this, arguments, function* ({ chainId } = {}) {
      const [provider, account] = yield Promise.all([this.getProvider(), this.getAccount()]);
      const chain = this.chains.find((x) => x.id === chainId);
      if (!provider)
        throw new Error("provider is required.");
      return createWalletClient({
        account,
        chain,
        transport: custom(provider)
      });
    });
  }
  isAuthorized() {
    return __async(this, null, function* () {
      if (!this.options.auth) {
        throw new Error("Please init Particle first");
      }
      return this.options.auth.isLogin() && this.options.auth.walletExist();
    });
  }
  switchChain(chainId) {
    return __async(this, null, function* () {
      var _a;
      const provider = yield this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const id = `0x${chainId.toString(16)}`;
      try {
        yield provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: id }]
        });
        return (_a = this.chains.find((x) => x.id === chainId)) != null ? _a : {
          id: chainId,
          name: `Chain ${id}`,
          network: `${id}`,
          nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
          rpcUrls: { default: { http: [""] }, public: { http: [""] } }
        };
      } catch (error) {
        const chain = this.chains.find((x) => x.id === chainId);
        if (!chain)
          throw new ChainNotConfiguredError({ chainId, connectorId: this.id });
        throw new SwitchChainError(error);
      }
    });
  }
};
var particleWallet = ({ chains, authType }) => ({
  id: authType ? `particle${authType}` : "particle",
  name: authType ? titleCase(authType) : "Particle",
  iconUrl: () => __async(void 0, null, function* () {
    const icons = yield import("./icons-JBREMNTX-JNQSKNX7.js");
    return authType ? icons[authType] : icons.particle;
  }),
  iconBackground: authType ? "#ffffff" : "#d61ace",
  installed: typeof window !== "undefined",
  createConnector: () => {
    var _a;
    const connector = new ParticleConnector({
      chains,
      options: {
        auth: typeof window === "undefined" ? void 0 : (_a = window.particle) == null ? void 0 : _a.auth,
        authType
      }
    });
    return {
      connector
    };
  }
});
export {
  particleWallet
};
//# sourceMappingURL=@particle-network_rainbowkit-ext.js.map
